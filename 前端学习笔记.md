# 						前端学习笔记

# 1 HTML

## 1.1  介绍

* HTML指的是超文本标记/标签语言(Hyper Text Markup Language)
* 专门制作网页的计算机语言
* 普通的文本就是英文单词，英文字母一样的存在
* 超文本的意思是有一些单词或字母，在网页浏览器的世界中被赋予了特殊的权利
  比如:我们都是普通人，但是有些人经过国家的选拔，穿上警服之后，他就被赋予了执法的特殊权利，普通人是没有执法权的。
  字母img只是普通的字母，没什么特殊的含义。而<img>被加上尖括号后，在网页的世界中，就具备了显示图片的作用。



## 1.2 使用记事本开发第一个网页

* 在计算机任意的位置，创建一个空白的记事本
* 重点：文件的后缀名必须是"htm"或"html"
* 鼠标右键文件，选择打开方式为“记事本”，输入下面代码

```
<html>
    <head>
        <title>拉钩有我</title>
    </head>
    <body>
        必须火！
    </body>
</html>
```

保存文件，双击文件会以计算机默认的浏览器运行，你的第一个网页制作完成了



注意：

1.<htm>标签它代表当前页面是一个HTML
2.<head>标签中可以声明HTML页面的相关信息
3.<body>标签中它主要是用于显示页面信息
4.标签要有开始有结束，*成双成对
4.开始标签与结束标签中的内容是标签的内容，如果没有标签内容，可以让标签自关闭<br/>5.大多数标签它具有属性属性值要使用引号引起来
6.HTML它本身是不区分大小写的。



# 2  HTML的使用

## 2.1 文件标签

<htmi>标签:代表当前书写的是一个HTML文档

<head>标签:存储的本页面的一些重要的信息，它不会显示

    <head>标签:有一个子标签<title>它是用于定义页面的标题的
    
    <body>标签:书写的内容会显示出来

<body>标签的属性
1.text：用于设置文字颜色
2.bgcolor：用于设置页面的背景色
3.background：用于设置页面的背景图片



## 2.2 排版标签

### 2.2.1 HTML注释

![image-20230210122648275](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230210122648275.png)



### 2.2.2 换行标签

<br/> 标签就是一个换行(回车)功能标签，标签中的/可有可无的

有/是HTML语言的标准化，但是HTML语言是一门不那么严谨的语言



### 2.2.3 段落标签

在<p>标签中的内容，会在开始与结束之间产生一个空白行，并且它会自动换行

常用属性align 他的作用是设置段落中的内容对齐方式 可取值有left right center



### 2.2.4 水平线标签 

<hr>标签会在页面上产生一个水平线

对于hr标签他有常用属性：

* align：可取值有left、right、center 代表水平线位置
* size：代表水平线厚度（粗细）
* width：代表水平线宽度
* color：水平线的颜色

<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230210125301193.png" alt="image-20230210125301193" style="zoom:150%;" />

单位：size="5" ，5是默认的单位，为“像素”，像素就是构成计算机图片的最小单位！

也可以使用百分比，size= “50%”

  

### 2.2.5 分区标签

div是一个**块**标签，用来进行布局的

普通的div并没有什么效果，肉眼也看不到，但div与CSS结合，就会更好对网页进行排版

div与span都是“容器”的作用，具体区别：

* div会自动换行，我们也叫这样的标签为块级标签
* span标签它不自动换行，我们也叫它为行内元素
* div：整体划分区块
* span：局部划分



## 2.3 字体标签

### 2.3.1 字体标签

<font>标签可以设置字体，字的大小以及颜色，常用属性：

* face：用于设置字体，例如 宋体 隶书 楷体
* size：用于设置字体大小（大小默认设置1-7,7最大，想更大，往后学css即可）
* color：用于设置字的颜色

注：

我们所看到的屏幕上所有的颜色都是由红、绿、蓝这三种基色调混合而成的

每一种颜色的饱和度和透明度都是可以变化的，用0~255的数值来表示。如纯红色表示为（255,0,0），十六进制表示为#FF0000。

按这种表达方式，理论上我们可以得到256 * 256 * 256 = 16777216 种颜色

1. 使用十六进制方式，取值范围#000000~#FFFFFF（黑色到白色）。当颜色值为#cc3300时，可简化成#c30这种方式

```
<body> bgcolor="666">
```

2. RGB颜色表示法：RGB（x,y,z）。x、z、y是0~255之间的整数。rgb字母大小写无所谓

```
<body> bgcolor="rgb(11,11,11)">
```

(在线颜色选择器：http://www.86y.org/code/colorpicker/color.html)

在word中字体查看是否下载成功



### 2.3.2 标题标记

给一段文字起一个标题

《<h1>---<h6>》


    h1最大 h6最小，它们代表的是标题

自动换行，字体加粗，标题与标题之间产生一定的距离

注意：在HTML中允许标签进行嵌套的，但是一般都包裹嵌套，而不可进行交叉嵌套



### 2.3.3 格式化标签

* <b>：字体加粗
* <i>：字体倾斜
* <del>：删除线
* <u>：下划线



## 2.4 列表标签

* ### ol：有序列表

  * type='A'：字母排序
  * type='I'：罗马排序
  * start="3"：序列从几开始

* ### ul：无序列表

  * type=“disc”：默认，实心圆
  * type="square"：方块
  * type=“circle”：空心圆

例子：

```html
    辣子鸡丁
    打卤面
    陕西油泼面
    <h1>有序列表</h1>
    <ol>
        <li>辣子鸡丁</li>
        <li>打卤面</li>
        <li>陕西油泼面</li>
        <li>锅包肉</li>
    </ol>

    <ol type="A">
        <li>辣子鸡丁</li>
        <li>打卤面</li>
        <li>陕西油泼面</li>
        <li>锅包肉</li>
    </ol>

    <ol type="I">
        <li>辣子鸡丁</li>
        <li>打卤面</li>
        <li>陕西油泼面</li>
        <li>锅包肉</li>
    </ol>

    <ol start="2">
        <li>辣子鸡丁</li>
        <li>打卤面</li>
        <li>陕西油泼面</li>
        <li>锅包肉</li>
    </ol>

    <hr>
    <h2>无序列表</h2>
    <ul>
        <li>辣子鸡丁</li>
        <li>打卤面</li>
        <li>陕西油泼面</li>
        <li>锅包肉</li>
    </ul>

    <ul type="circle">
        <li>辣子鸡丁</li>
        <li>打卤面</li>
        <li>陕西油泼面</li>
        <li>锅包肉</li>
    </ul>

    <ul type="square">
        <li>辣子鸡丁</li>
        <li>打卤面</li>
        <li>陕西油泼面</li>
        <li>锅包肉</li>
    </ul>
```



## 2.5 图形标签

<img>可以让我们在网页引入一张图片，常用属性：

1. src代表的图片的路径
2. width图片的宽度
3. height 图片的高度
4. border 用于设置图片的边框
5. alt 如果图片不可以显示时，默认显示的文本信息
6. title鼠标悬停图片上，默认显示的文本信息
7. align 图片附件文字的对齐方式，可取值有
   * left：把图像对齐到左边
   * right：把图像对齐到右边
   * middle：把图像与中央对齐
   * top：把图像与顶部对齐
   * bottom：把图像与底部对齐（默认）



## 2.6 超链接标签

<a>标签，可以实现跳转到其他页面操作

超链接内容不仅可以是文本。也可以是图片等信息

常用属性：

1. href 代表的我们要跳转的路径
2. target 这个属性规定在何处打开这个链接文档，可取值：
   * _blank 在新窗口中打开页面
   * _self 默认。在本窗口打开页面

![image-20230210151422093](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230210151422093.png)



功能性连接：

1. 发邮件：

```
<a href="mailto:sunguoan@163.com">联系站长</a>
```

2. QQ聊天窗口

```
<a href="tencent://message/?uin=19998539&Menu=yes">
	<img border="0" src="http://wpa.qq.com/pa?p=1:615050000:7"/>
<a/>
```



## 2.7 表格

* （<table>） ： 定义一个表格
  * border：边框，取值是像素为单位
  * width：代表的表格的宽度
  * align ：代表表格的对齐方式：取值
    * left 左对齐表格
    * right 右对齐表格
    * center 居中对齐表格
  * cellspacing：单元格间距（通常设置0表示单线表格）   
* <tr>：表格中的行(Table Row)
  * align 代表表格的对齐方式：取值
    * left 左对齐内容
    * right 右对齐内容
    * center 居中对齐内容（th元素的默认值）
* <td>：表格中的数据单元格（Table DataCell）
  * colspan 指示列的合并
  * rowspan 指示行的合并



## 2.8 表单标签

表单可以让我们将录入信息携带到服务器端

简单说，通过表单可以将要提交的数据提交到指定的位置

但一个一个的提交，不方便，表单正好解决了这个问题，将所有的数据形成一个整体，一起提交给服务器

常见的登录页面，注册页面 都离不开表单的应用

![image-20230210161045991](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230210161045991.png)



### 2.8.1 form属性

action：整个表单提交的目的地

method：表单提交的方式

* get：提交时，传输数据量少（传递普通文字信息，传递照片会失败），明文提交（在浏览器的url后面会显示提交的数据，不适合用于登录）
* post：提交时，传输数据量大（传递文字和图片都行），密文提交（浏览器的url后面看不到提交的数据）



### 2.8.2 表单中的元素（控件）

* <input>元素的type属性

  * text：默认值，普通的文本输入框
    * placeholder属性：提示文本
    * maxlength属性：最多能输入字符数量
  * password：密码输入框
  * checkbox：多选框/复选框
    * checked：被选中
  * radio：单选按钮
  * file：上传文件
  * reset：重置按钮
  * submit：提交按钮

  

* （<select>）：下拉列表/下拉框
  * <option>：列表中的项
    * selected：被选中



* （<textarea>）：文本域（多行文本框）
  * 可以通过cols和rows属性来规定textarea的尺寸，不过更好的办法是使用CSS的height和width属性



* <button>：按钮
  * 在form表单中，作用和submit一样
  * 不在form表单中，就是普通按钮

演示：

```html
    <form action="baidu">
        <p>账号：<input placeholder="请输入账号..." maxlength="5"></p>
        <p>密码：<input type="password"></p>
        <p>爱好：
            <input type="checkbox"> 抽烟
            <input type="checkbox"> 喝酒
            <input type="checkbox"> 烫头
            <input type="checkbox"> 泡澡
        </p>
        <p>性别：
            <input type="radio" name="sex"> 男
            <input type="radio" name="sex" checked="checked"> 女
        </p>

        <p>
            身份：
            <input type="radio" name="role"> ceo 
            <input type="radio" name="role"> cto
            <input type="radio" name="role"> coo
            <input type="radio" name="role" checked="checked"> ufo
        </p>

        <p>头像：
            <input type="file">
        </p>

        <p>血型：
            <select>
                <option>A型</option>
                <option>B型</option>
                <option>C型</option>
                <option selected="selected">O型</option>
            </select>
        </p>
        <p>个人简介：
            <textarea cols="10" rows="5"></textarea>
        </p>

        <p>
            <input type="reset" value="清空">
            <input type="submit" value="提交">
            <input type="button" value="取消">
            <button>保存</button>
        </p>
```



## 2.9 框架标签

通过<frameset>和<frame>框架标签可以定制HTML页面布局，可以理解为：用多个页面拼装成一个页面。

注意，框架标签和body标签不共存。“有你没我，有我没你”

代码演示：

```
<frameset rows="10%,*,13%">
    <frame src="top.html"></frame>
<frameset cols="15%,*">
    <frame src="left.html"></frame>
    <frame src="right.html"></frame>
</frameset>
    <frame src="foot.html"></frame>

</frameset>
```

![image-20230210192724761](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230210192724761.png)



## 2.10 其他标签与特殊字符

### 2.10.1 <meta>标签

```
<meta>标签必须写在<head>标签之间
```

```
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
```

1. 当前页面的字符编码 （GBK：中文简体）

2. 这里的名字是viewport(显示窗口)

   数据是文本内容 content=“width=device-width，initial-scale=1.0”

   也就是显示窗口 宽度是客户端的屏幕宽度（就是满屏！），显示的文字和图形的初始化比例是1.0

3. 每个电脑内置的IE版本是不一样的，为了兼容所有的版本以最高级模式渲染文档，也就是任何IE版本都以当前版本所支持的最高级标准模式渲染

* 通过meta标签来设置页面加载后在指定的时间后跳转到指定的页面’

```
<meta http-equiv="refresh" content="5; url=http://www.lagou.com">
```

注意：在HTML中如果跳转的互联网上的网站资源，那么我们在书写路径时，一定要带协议的路径



### 2.10.2 <link>标签

后面我们会使用link标签来导入css

注意：link标签也必须写在<head>标签中



### 2.10.3 特殊字符

http://123.5ikfc.com/html/character.html



## 3 HTML5新特性

### 3.1 HTML4与HTML5的区别

H5包含H4

1. 大小写不敏感

   （1）标签

   （2）属性

   （3）属性的值

   ```
   <input tyPe="passWord">
   ```

2. 引号可省略

   ```
   <input type="password">
   <input type=password>
   ```

3. 省略了结尾标签

```
<p>哈哈哈哈哈
```

说是省略，其实运行起来，查看源代码，html是自动帮我们补全了



### 3.2 新增语义化标签

html4中，所有的容器标签95%都会使用div，div过多的话，很难区分彼此新增许多语义化标签，让div"见名知意"。

* section标签:表示页面中的内容区域，部分，页面的主体部分
* article标签:文章。
* aside标签:文章内容之外的，标题
* header标签:头部，页，页面的顶部
* hgroup根签:内容与棕题的组合
* nav标签:导航
* figure抓饭:图文并茂。
* foot:页践，责面的底部

![image-20230210213935068](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230210213935068.png)





### 3.3 媒体标签

想在网页上播放视频，就要使用<video>,属性有：

* src：媒体资源的位置
* controls：控制面板
* autoplay：自动播放（谷歌失效，360浏览器可以）
* loop：循环播放

```
<video src="img/html-css-js之间的关系.mp4" controls loop autoplay></vedio>
```



### 3.4 新增表单控件

表单的控件更加丰富了

* <input>：修改type属性
  * color：调色板
  * date：日历
  * month：月历
  * week：周历
  * number：数值域
    * min：最小值
    * max：最大值
    * step：递增量
  * range：滑块
  * search：搜索框（带x号，可一键删除框中内容）
* 进度条<progress/>
* 高亮<mark>
* 联想输入框<datalist>（模糊查询）
  * 选项<option>



# 1 CSS

## 1.1 CSS介绍

* CSS是指层叠样式cascading style sheets
* 通过CSS可以让我们定义HTML元素如何显示
* CSS可以让我们原本HTML不能描述的效果，通过CSS描述出来
* 通过CSS描述我们的HTML页面，可以让我们的页面更加漂亮，可以提高工作效率



# 2 CSS与HTML结合方式

##  2.1 第一种方式 内联/行内样式

就是在我们的HTML标签上通过style属性来引用CSS代码

优点：简单方便

缺点：只能对一个标签进行修饰

![image-20230211120925164](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230211120925164.png)



## 2.2 第二种方式 内部样式表

我们通过<style>标签来声明我们的CSS，通常<style>标签我们推荐写在head和body之间，也就是“脖子”的位置

优点：可以通过多个标签进行统一的样式设置

缺点：他只能在本页面上进行修饰

语法：选择器（属性：值；属性：值）

![image-20230211121447791](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230211121447791.png)





## 2.3 第三种方式 外部样式表

我们需要单独定义一个CSS文件，注意CSS文件的后缀名就是CSS

在根目录下，创建CSS目录，在CSS目录中创建CSS文件css01.css

在<head>中使用<link>标签引用外部的css文件

![image-20230211122328008](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230211122328008.png)

![image-20230211122343147](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230211122343147.png)

方式二：

```
<style>
@import url(test01.css)
</style>
```

关于外部导入CSS使用<link>与@import的区别？

1. 加载顺序不同

* @import方式导入会先加载HTML，然后才导入css样式，俺么如果网络条件不好，就会先看到没有修饰的页面，然后才看到修饰后的页面
* 如果使用link方式，他会加载样式表，也就是说，我们看到的直接就是修饰的页面

2. @import方式导入css样式，它是不支持JavaScript的动态修改的，而link支持

三种样式表的优先级：满足就近原则

内联 > 内部 > 外部



# 3 CSS的使用

## 3.1 css中的选择器

### 3.1.1 元素(标签)选择器

他可以对页面上相同的标签进行统一的设置，他描述的就是标签的名称

![image-20230211195856511](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230211195856511.png)



### 3.1.3 id选择器

他只能选择一个元素，使用“a”引入，引用的是元素的id属性值

id选择器，比类选择器更具唯一性

![image-20230211200131200](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230211200131200.png)



### 3.1.4 选择器组

逗号表示，谁和谁，例如，我有手机，你有手机，他也有手机，一条一条写太麻烦，就可以合并编写

```
我，你，他{
	手机
}
```

![image-20230211201200471](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230211201200471.png)



### 3.1.5 派生选择器

* 子代：父子关系（隔代不管）
* 后代：父子孙，管孙，从孙...

![image-20230211203122067](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230211203122067.png)















### 3.1.6 CSS伪类

* CSS伪类可对CSS的选择题添加一些特殊效果
* 伪类属性列表：
  * ：active 向被激活的元素添加样式
  * ：hover 当鼠标悬浮在元素上方时，向元素添加样式
  * ：link 向未被访问的链接添加样式
  * ：visited 向已被访问的链接添加样式
  * ：first-child 向元素的第一个子元素添加样式

超链接的伪类：要遵守使用顺序，爱恨原则LoVeHAte

```
a:link{ color:#FF0000 }  /*未访问的链接*/
a:visited{ color:#00FF00 }  /*已访问的链接*/
a:hover { color: #FF00FF } /*鼠标移动到链接上*/
a:active {color:#0000FF} /*选定的链接*/
```

![image-20230211212342043](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230211212342043.png)

![image-20230211213640887](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230211213640887.png)



# 3.2 CSS基本属性

## 3.2.1 文本属性

* 指定字体：font-family：value；
* 字体大小：font-size：value；
  * px：像素
  * em：倍数
* 字体加粗：font-weight：normal/bold；
* 文本颜色：color：value；
* 文本排列：text-align：left/right/center;
* 文字修饰：text-decoration：none/underline;
* 行高：line-height：value;
* 首行文本缩进：text-indent：value(2em);

```html
<style>
#title{
    font-family: "隶书";
    /* font-size: 5em; 默认字体大小五倍 */
    font-size: 2em;
    font-weight: bold; /*字体加粗*/
    color: red; /*字体颜色*/
    text-align: center; /*居中对齐*/
    text-decoration: underline; /*下划线*/
    line-height: 30px;/*行高*/

}
.content{
    text-indent: 2em; /*首行缩进*/
}
</style>
<body>
    <p id="title">中华人民共和国万岁!</p>
    <p style="text-align: right;">作者:老孙</p>
    <p class="content">我们相亲相爱是一家人！</p>
    <p>我们相亲相爱是一家人！</p>
</body>
```



3.2.2 背景属性

CSS允许应用纯色作为背景，也允许使用背景图像创建相当复杂的效果

* background-color 设置元素的背景颜色
* background-image 把图像设置为背景

```
background-image:url('img/1.jgp');
```

* background-repeat 设置背景图像的墙纸效果，是否及如何重复
  * repeat：在垂直方向和水平方向重复，为重复值
  * repeat-x：仅在水平方向重复
  * repeat-y：仅在垂直方向重复
  * no-repeat：仅显示一次
* background-position 设置背景图像的起始位置
* 1：控制水平方向x轴：正值，向右移动；负值向左移动
* 2：控制垂直方向y轴：正值，向下移动；负值向上移动

```
/*图片向左移动50px，向下移动100px（可以为负值）*/
background-position:50px 100px;
```

* background-attachment 背景图像是否固定或者随着页面的其余部分滚动
  * 默认值是 scroll：是、默认情况下，背景会随文档滚动
  * 可取值为 fixed：背景图像固定，并不会随着页面的其余部分滚动，常用于实现称为水印的图像

```
background-attachment: fixed;
```

代码演示：

```html
<style>
    div{
        width: 1800px;
        height: 900px;
        background-color: pink; /*背景颜色*/
        background-image: url('D:/剪辑视频库/素材库/22.jpg');
        background-repeat: no-repeat; /*平铺方式*/
        background-position: 100px 0px; /*背景的位置（移动）*/
        background-attachment: fixed; /*固定的背景*/
    }
</style>
```



## 3.2.3 列表属性

CSS 列表属性作用如下：

* 设置不同的列表项标记为有序列表
* 设置不同的列表项标记为无序列表
* 设置列表项标记为图像

有两种类型的列表：

* 无序列表-列表项标记用特殊图形（如小黑点，小方框等）
* 有序列表-列表项的标记有数字或字母

使用CSS，可以进一步的样式，并可用图像作列表项标记

* none：无标记
* disc：默认。标记是实心圆
* circle：标记是空心圆
* square：标记是实心方块
* decimal：标记是数字
* decimal-leading-zero：0开头的数字标记（01,02,03，等）
* lower-roman：小写罗马数字（i,ii,iii,iv,v,等）
* upper-roman：大写罗马数字(I,II,III,IV,V，等)
* lower-alpha：小写英文字母The marker is lower-alpher(a,b,c,d,e,等)
* upper-alpha：大写英文字母The marker is upper-alpher(A,B,C,D,E,等)

```html
<style>
.a{
    list-style-type: none;
}

.b{
    list-style-type:decimal-leading-zero;
}

.c{
    list-style: upper-roman;
}
.d{
    list-style-type: upper-alpha;
}
.e{
    list-style-image: url('D:/剪辑视频库/素材库/22.jpg');
}  
</style>

<body>
    <ul class="a">
        <li>曹操</li>
        <li>刘备</li>
        <li>孙权</li>
    </ul>

    <ol class="b">
        <li>吕布</li>
        <li>赵云</li>
        <li>典韦</li>
    </ol>

    <ol class="c">
        <li>关羽</li>
        <li>马超</li>
        <li>张飞</li>
    </ol>

    <ol class="d">
        <li>黄忠</li>
        <li>夏侯惇</li>
        <li>姜维</li>
    </ol>

    <ol class="e">
        <li>老孙</li>
        <li>老杨</li>
        <li>老西</li>
    </ol>
```



## 3.2.4 边框

CSS边框属性允许你指定一个元素边框的样式和颜色

![image-20230212154025433](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230212154025433.png)



border-style取值：

* solid 实心线
* dotted 点线
* dashed 虚线
* double 双线
* groove 3D效果凹槽
* ridge 3D脊边框
* inset
* outset



3.2.5 轮廓属性

轮廓（outline）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用

轮廓和边框的区别：

* 边框（border）：可以是围绕元素内容和内边距的一条或多条线；
* 轮廓（outline）：是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用

CSS outline属性规定元素轮廓的样式、颜色和宽度

![image-20230212155245268](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230212155245268.png)



3.2.6 盒子模型

所有HTML元素可以看作盒子，在CSS中，“box model”这一术语是用来设计和布局时使用

CSS盒子模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容

盒子模型允许我们在其他元素和周围元素边框之间的空间放置元素

下面的图片说明了盒子模型（Box Model）

![image-20230212155739514](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230212155739514.png)

* margin（外边距）：盒子与盒子之间的距离
* border（边框）：盒子的保护壳
* padding（内边距/填充）·内填充，盒子边与内容之间的距离
* content（内容）：盒子的内容，显示的文本或图像

```html
<style>
    div{
        width: 200px;
        height: 200px;
        border: 2px solid greenyellow;
        margin-top: 50px; /*上外边距*/
        margin-left: 100px; /*左外边距*/
        padding-top: 20px; /*上内边距*/
        padding-left: 40px; /*左内边距*/
    }
</style>
```



# 3.3 CSS定位

## 3.3.1 默认定位

* 块级元素：h1~h6，p，div等，自上而下（自动换行）；可以改变宽高

![image-20230212163147366](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230212163147366.png)



* 行内元素：a,b,span等，从左向右，水平排列（不会换行）；不能改变宽高

![image-20230212163406648](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230212163406648.png)



* 行内块元素：input，img等，从左到右，水平排列（自动换行）；还可以改变宽高

![image-20230212172225492](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230212172225492.png)



## 3.3.2 浮动定位

* 让元素飞起来，不仅可以靠着左边或右边，还可以消除“块级”
* float取值：
  * none：不浮动
  * left：贴着左边 浮动
  * right：贴着右边浮动

![image-20230212173709690](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230212173709690.png)



## 3.3.3 相对定位

和原来的位置进行比较，进行移动定位（偏移）

![image-20230212193547120](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230212193547120.png)



## 3.3.4 绝对定位

本元素与已定位的祖先元素的距离

* 如果父级元素定位了，就以父级为参照物
* 如果父级没有定位，找爷爷级，爷爷级定位了，以爷爷为参照物
* 如果爷爷没定位，继续向上找，都没定位的话，body是最终选择

```
<div class="yeye">
	<div class="father">
		<div class="a">1<div>
		<div class="b">2<div>
		<div class="c">3<div>
	</div>
</div>
```

* 以父节点作为参照物

![image-20230212195742998](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230212195742998.png)



## 3.3.5 固定定位

将元素的内容固定在页面的某个位置，当用户向下滚动页面时元素框并不随着移动

![image-20230212200909914](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230212200909914.png)

```html
<style>
    .gg{
        width: 200px;
        height: 200px;
        background-color: aqua;
        position: fixed;
        top: 100px;
        left: 200px;
    }
</style>
```



## 3.3.6 z-index

如果有重叠元素，使用z轴属性，定义上下层次

![image-20230212203412562](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230212203412562.png)

注意：

* z轴属性，要配合相对或绝对定位来使用
* z值没有额定数值（整型就可以，具体用数字几，悉听尊便）



# 4 CSS3

## 4.1 圆角

border-radius：左上 右上 右下 左下

border-radius：四个角

border-radius：50%；圆形

| border-radius: 1px 10px 30px 50px; | ![image-20230212204606402](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230212204606402.png) |
| ---------------------------------- | ------------------------------------------------------------ |
| **border-radius: 30px;**           | ![image-20230212204656561](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230212204656561.png) |



4.2 盒子阴影

box-shadow：1 2 3 4 5；

1：水平偏移

2：垂直偏移

3：模糊半径

4：扩张半径

5：颜色

![image-20230212205140253](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230212205140253.png)



## 4.3 渐变

### 4.3.1 线性渐变

```
background:linear-gradient([方向/角度],颜色列表);
```

![image-20230212210919661](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230212210919661.png)



### 4.3.2 径向渐变

以圆心向外发散

```
background:radial-gradient(颜色列表);
```

![image-20230212210852519](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230212210852519.png)



## 4.4 背景

### 4.4.1 背景位置

background-origin：指定了背景图像的位置区域

* border-box：背景贴边框的边
* padding-box：背景贴内边框的边
* content-box：背景贴内容的边

```html
<style>
div{
    background : url("D:/剪辑视频库/素材库/22.jpg") no-repeat;
    width: 200px;
    height: 80px;
    margin: 20px;
    border: 10px dashed red;
    padding: 20px;
}
.a{
    background-origin: border-box;
}
.b{
    background-origin: padding-box;
}
.c{
    background-origin: content-box;
}
</style>
```



### 4.4.2 背景裁剪

background-clip：

* border-box 边框开切
* padding-box 内边距开切
* content-box 内容开切

```html
<style>
    div{
        width: 200px;
        height: 80px;
        border: 10px dashed red;
        background-color: aquamarine;
        margin: 20px;
        padding: 20px;
    }
.a{
    background-clip: border-box;
}
.b{
    background-clip: padding-box;
}
.c{
    background-clip: content-box;
}
</style>
```

![image-20230212212732647](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230212212732647.png)



### 4.4.3 背景大小

background-size：

* cover 缩放成完全覆盖背景区域最小大小 (完全覆盖)
* contain 缩放成完全适应背景区域最大大小 （完全适应）

```html
<style>
div{
    background:url("D:/剪辑视频库/素材库/22.jpg") no-repeat;
    width: 200px;
    height: 200px;
    border: 2px solid red;
    margin: 20px;
}
.a{
    background-size: cover; /*完全覆盖*/
}
.b{
    background-size: contain; /*完全适应*/
}
</style>
```

![image-20230212213407741](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230212213407741.png)



## 4.5 过渡动画

### 4.5.1 过渡

从一个状态到另一个状态，中间的“缓慢”过程；

缺点是，控制不了中间某个信息点。

transition{1,2,3,4}

1：过渡或动画模拟的CSS属性

2：完成过渡所需要的所有时间（2s内完成）

3：过渡函数。。。

| linear      | 匀速         |
| ----------- | ------------ |
| ease        | 逐渐慢下来   |
| ease-in     | 加速         |
| ease-out    | 减速         |
| ease-in-out | 先加速后减速 |

![image-20230212220520879](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230212220520879.png)

4：过渡开始出现的延迟时间

```html
transition: width 2s ease 1s;
```

目前CSS3只开发出部分的过渡属性，如下表：

![image-20230212221452936](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230212221452936.png)

```html
<style>
div{
    width: 100px;
    height: 50px;
    border: 2px solid red;
}
.a{
    transition: width 2s ease 1s; /*1秒过后，div在2秒内匀速缓慢的变宽*/
}
div:hover{width: 300px;} /*触发div变宽*/
</style>
```



### 4.5.2 动画

从一个状态到另一个状态，过程中每一个时间点都可以控制

* 关键帧：@keyframes 动画帧{from{} to{}} 或者{0%{} 20%{}...}
* 动画属性：animation{1,2,3,4,5}
  1. 动画帧
  2. 执行时间
  3. 过渡函数
  4. 动画执行的延迟（可省略）
  5. 动画执行的次数

需求1：一个元素从左向右移动，2秒内执行2次

```html
<style>
    div{
        width: 700px;
        border: 1px solid red;
        background-size: contain;
    }
    @keyframes x{
        from{margin-left: 0px;}
        to{margin-left: 550px;}
    }

    img{
        animation: x 3s linear 2;
    }
</style>
```

需求2：一个元素从左向右移动，1秒内执行完成，无限次交替执行

infinite：无限次

alternate：来回执行（交替，一去一回）

```html
<style>
    .wai{
        width: 600px;
        height: 100px;
        border: 2px solid red;
    }
    .nei{
        width: 40px;
        height: 80px;
        border: 2px solid red;
        margin: 5px;
        background: red;
    }
    .nei{
        animation: x 3s linear infinite alternate;
    }
    @keyframes x{
        0%{margin-left: 0px;}
        25%{background: yellow;}
        50%{background: goldenrod;}
        75%{background: palevioletred;}
        100%{
            background: coral;
            margin-left: 550px ;
        }
    }
</style>
```



# JavaScript

## 1.JavaScrip介绍

* 虽然是Java作为前缀，但Java和JavaScript的关系，就像老婆和老婆饼之间的关系，没有一毛钱关系
* 网景公司在Netscape 2.0首先推出了JavaScript
* JavaScript的正式名称是“ECMAScript”，此标准由ECMA组织发展和维护，商标js
* JavaScript是一种网页编程技术，用来向HTML页面添加交互行为
* JavaScript是一种基于对象和事件驱动的解释性脚本语言，直接嵌入HTML页面，由浏览器解释执行代码，不进行预编译



### 1.1 js的特点

* 可以使用任何文本编辑工具编写，只需要浏览器就可以执行程序（后面会学习不用浏览器也可以）
* 解释运行：事先不编译，逐行执行
* 基于对象：内置大量现成对象
* 适宜：
  * 客户端数据计算
  * 客户端表单合法性验证
  * 浏览器事件的触发
  * 网页特殊显示效果制作



### 1.2 js的组成

* ECMAScript：定义核心语法，关键字，运算符，数据类型等系列标准
* DOM：文档对象模型，将一个htm页面的所有节点看成是一个一个的对象，更有层次感的管理每一个节点。
* BOM：浏览器对象模型，是对浏觅群窗口进行访问和操作，使用 BOM，开发者可以移动窗口、改变状态栏中的文本以及执行其他与页面内容不直接相关的动作。使B0M 独树一帜且又常常令人怀疑的地方在于，它只是JavaScript 的一个部分，没有任何相关的准
  * 弹出新的浏览器窗口
  * 移动、关闭浏览器窗口以及调整窗口大小
  * 提供Web浏览器详细信息的定位对象
  * 提供用户屏幕分辨率详细信息的屏幕对象
  * 对cookie的支持
  * IE扩展了BOM，加入了ActiveXObject类，可以通过JavaScript实例化ActiveX对象，进而实现ajax局部刷新技术



# 2.HTML与JavaScript结合方式

使用js的三种方式

## 2.1 行内脚本

1.点击按钮（触发）

2.弹框（具体的操作）

```
<botton onclick="alert('弹框测试')>点我一下</bottom>
```

## 2.2 内部脚本

1. 使用<script></script>
2. 标准是写在head和body之间（脖子之间）,但其实只要写在html文件内部就可以

```
<body>
	<script>
		alert("弹框");
	</script>
</body>
```



## 2.3 外部脚本

1. 在项目根目录下创建一个目录js
2. 在js目录中创建一个文件，后缀名是.js
3. 在html页面中，使用

```
<script src="js/xx.js"></script>
```

以上使用脚本的三种方式的优先级，谁在上，谁先执行。因为是解释性语言



# 3.JavaScript的使用

## 3.1 变量

* 因为js是弱类型语言，所有，在定义变量的时候，所有的数据类型都是var
* 声明变量：var x;    var x,y;
* 数值类型：number
  * 不区分整型数值和浮点型数值
  * 所有数字都采用64位浮点格式存储，类似于double格式
* 字符串：string
  * 首尾由单引号或双引号括起

```
var aa="欢迎来到\"JavaScript世界";
```

* 布尔类型
  * 仅有两个值：true和FALSE也代表0和1 
  * 实际运算中true=1，false=0



### 3.1.1 自动类型转换

```
数字 + 字符串：数字转换为字符串		10+'a' -> 10a
数字 + 布尔值：true转换为1，false转换为0		true+5 -> 6
字符串 + 布尔值：布尔值转换为字符串true或false	true+'a' ->truea
布尔值 + 布尔值：布尔值转换为数值1或0	true+true -> 2
```



### 3.1.2 数据类型转换函数

* parseInt：强制转换成整数
  * 如果不能转换，则返回NaN（NaN属性是代表非数字值的特殊值，该属性用于指示某个值不是数字）
  * 例如：parseInt("6.32")=6
* parseFloat：强制转换成浮点数
  * 如果不能转换，则返回NaN
  * 例如：parseFloat("6.32")=6.32
* typeof：查询数值当前类型，返回string/number/boolean/object
  * 例如：typeof("test" + 3)="string"



### 3.1.3 null 与 undefined

* null在程序中代表“无值”或者“无对象”
  * 可以通过给一个变量赋值null来清楚变量的内容
* undefined
  * 声明了变量但从未赋值或者对象属性不存在



3.1.4 算术运算

* 加(+)、减(-)、乘(*)、除(/)、余数(%)
  * -可以表示减号，也可以表示负号，如x=-y
  * +可以表示加法，也可以用于字符串的连接
* 递增（++），递减（--）
  * i++相当于i=i+1
  * i--相当于i=i-1



3.1.5 关系运算

* 严格相等：===
  * 类型相同
  * 数值相同
* 非严格相等：！==

```
var a = "10";
var b = 10;
if(a == b)
	alert("equal");
if(a === b)
	alert("same");
```



### 3.1.6 逻辑运算符

* 逻辑非（!）、逻辑与（&&）、逻辑或（||）
* 逻辑运算的操作数均为boolean 表达式

![image-20230215211327236](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230215211327236.png)



### 3.1.7 控制语句

```
if(关系表达式){
	//语句块
}else{
	//语句块2
}
```

```
if(表达式1){
	//语句1;
}else if(表达式2){
	//语句2;
}else if(表达式3){
	//语句3;
}else{
	//语句4;
}
```

```
switch(表达式){
	case 值1: 
		//语句1;
		break;
	case 值2:
		//语句2;
		break;
	default:
		//语句4;
}
```

```
for(var i=1; i <=5; i++){
alert(i);
}
```

```
while(条件){
	//语句1;
	...
}
```



## 3.2 常用字符串API

* length：获取字符串的长度（字符串中字符的个数）属性，没有小括号

```
        var str = "hello";
        console.log(str.length);
```



* toUpperCase/toLowerCase：转大小写

```
        var name = "AngierSun";
        console.log(name.toUpperCase());
        console.log(name.toLowerCase());
```



* charAt（下标）：返回某个下标上的字符

```
        var str1 = "javascript网页教程";
        var str2 = str1.charAt(12);//下标12上的字符
        console.log(str2);//教
        var str3 = str1.charCodeAt(12);
        console.log(str3);//25945：（汉字“教”在unicode编码中的编码）
```



* indexof（字符）：查找字符串中字符出现的首次下标

```
        var str1 = "javascript网页教程";
        var str2 = str1.indexOf("a");
        console.log(str2); // 1 ,a字符在str1中第一次出现的下标
        var str3 = str1.lastIndexOf("a");
        console.log(str3); // 3 ,a字符在str1中最后一次出现的下标
```



* lastindexof（字符）：查找字符串中字符最后一次出现的下标

```
        var str3 = str1.lastIndexOf("a");
        console.log(str3); // 3 ,a字符在str1中最后一次出现的下标
```



* substring（开始结束）：截取字符串中一部分（结束是不包含的）

```
        var str1 = "abcdefgh";
        var str2 = str1.substring(2,4);
        console.log(str2); //cd 从2开始（包含），4结束（不包含）
```



* replace（旧的，新的）：将字符串中的旧字符替换成新字符

```
        var str1 = "abcde";
        var str2 = str1.replace("cd","xxx");
        console.log(str2); //abxxxe,将str1中的cd替换成xxx
```



* split（分割的节点）：一个字符串切割成N个小字符串，所以返回的是数组类型

```
        var str1 = "一,二,三,四,五";
        var arr = str1.split(",");
        console.log("共分割成："+arr.length);
        console.log("第三份是："+arr[2]);//三
```



## 3.3 数组

### 3.3.1 创建数组

```
var arr1 = new Array();
```



### 3.3.2 初始化数组的三种方式

```
//第一种
var arr1 = new Array();
arr1[0] = 110;
arr1[1] = 119;
arr1[2] = 120;
//第二种
var arr1 = new Array(10,"hello",true);
//第三种
var arr1 = [10,"a",true];
```



### 3.3.3 数组的常用方法

* tostring()：将数组转换成字符串

```
        var arr = [1,2,3,4];
        console.log("类型为"+typeof(arr));
        var str = arr.toString();//将数组转换为字符串
        console.log(str+"类型为"+typeof(str))
```



* join（连接符号）：将数组中的每个元素用连接符号连接成一个新的字符串

```
        var arr = [1,2,3,4];
        var str = arr.join("-");
        console.log(str+"类型为:"+typeof(str));
```



* concat(新元素)：将原来的数组连接新元素，原数组不变

```
        var arr = [1,2,3,4];
        var arrnew = arr.concat(5,6);//在arr数组后面添加新元素
        console.log(arrnew+"类型为:"+typeof(arrnew));
        console.log("原数组:"+arr);
```



* slice（开始，结束）：在数组中提取一部分，形成新的数组
  * 1，,2，3，4，5       slice(2,4)     结果3,4

```
        var arr = ['a','b','c','d','e','f','g','h'];
        var arrnew = arr.slice(2,4);//在arr数组中截取，从2开始（包含），4结束（不包含）
        console.log(arrnew); //cd
```



* reverse：数组的反转(倒序)

```
        var arr = [31,12,111,444];
        console.log(arr.toString());
        arr.reverse();//将数组中的元素倒序
        console.log(arr.toString()); 
```



* sort()：数组排序

  * arr.sort()：字符排序

  ```
          var arr = [31,12,111,444];
          arr.sort();//字符排序(不会按照字面量大小排序)
          console.log(arr);
  ```

  

  * arr.sort(func)：数值排序

```
        var arr = [31,12,111,444];
        arr.sort(laosun);//数字排序(会按照字面量大小排序)
        console.log(arr);

        //定义排序函数
        function laosun(a,b){
            return a-b;
        }
```



3.4 Math数学对象

* Math 对象用于执行数学任务
* 没有构造函数 Math()
* 无需创建，直接把Math 作为对象使用就可以调用其所有属性和方法

| 方法       | 描述                                                 |
| ---------- | ---------------------------------------------------- |
| abs(x)     | 返回数的绝对值                                       |
| acos(x)    | 返回数的反余弦值                                     |
| asin(x)    | 返回数的反正弦值                                     |
| atan(x)    | 以介于-PI/2 与 PI/2 弧度之间的数值来返回x的反正切值  |
| atan2(x,y) | 返回从x轴到点(x,y)的角度(介于-PI/2 与 PI/2 弧度之间) |
| ceil(x)    | 对数进行上舍入                                       |
| cos(x)     | 返回数的余弦                                         |
| exp(x)     | 返回e的指数                                          |
| floor(x)   | 对数进行下舍入                                       |
| log(x)     | 返回数的自然对数(底为e)                              |
| max(x,y)   | 返回x和y中的最高值                                   |
| min(x,y)   | 返回x和y中的最低值                                   |
| pow(x,y)   | 返回x的y次幂                                         |
| random()   | 返回 0 ~ 1 之间的随机数                              |
| round(x)   | 把数四舍五入为最接近的整数                           |
| sin(x)     | 返回数的正弦                                         |
| sqrt(x)    | 返回数的平方根                                       |
| tan(x)     | 返回角的正切                                         |
| toSource() | 返回该对象的源代码                                   |
| valueOf()  | 返回Math对象的原始值                                 |



## 3.5 Number对象

Number.fixed(2)：自带四舍五入技能

```
var n1 = new Number(12.3456);
var newn1 = n1.toFixed(2);
var n2 = new Number(12.3);
var newn2 = n2.toFixed(2);
```



## 3.6 正则表达式

对字符串执行模式匹配的强大工具

```
var reg1 = /^\d(3,6)$/;
var reg2 = new RegExp("^\\d{3,6}$");
```

| **字符**    | **描述**                                                     |
| ----------- | ------------------------------------------------------------ |
| \           | 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\\’ 匹配 “\” 而 “\(” 则匹配 “(”。 |
| ^           | 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。 |
| $           | 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。 |
| *           | 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 |
| +           | 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 |
| ?           | 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的”do” 。? 等价于 {0,1}。 |
| {n}         | n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 |
| {n,}        | n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 |
| {n,m}       | m 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 |
| ?           | 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。 |
| .           | 匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。 |
| (pattern)   | 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘′或‘′或‘’。 |
| (?:pattern) | 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (\|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y\|ies) 就是一个比 ‘industry\|industries’ 更简略的表达式。 |
| (?=pattern) | 正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，’Windows (?=95\|98\|NT\|2000)’ 能匹配 “Windows 2000″ 中的 “Windows” ，但不能匹配 “Windows 3.1″ 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 |
| (?!pattern) | 负向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如’Windows (?!95\|98\|NT\|2000)’ 能匹配 “Windows 3.1″ 中的 “Windows”，但不能匹配 “Windows 2000″ 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始 |
| x\|y        | 匹配 x 或 y。例如，’z\|food’ 能匹配 “z” 或 “food”。’(z\|f)ood’ 则匹配 “zood” 或 “food”。 |
| [xyz]       | 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 |
| [^xyz]      | 负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p'。 |
| [a-z]       | 字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。 |
| [^a-z]      | 负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。 |
| \b          | 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 |
| \B          | 匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 |
| \cx         | 匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 |
| \d          | 匹配一个数字字符。等价于 [0-9]。                             |
| \D          | 匹配一个非数字字符。等价于 [^0-9]。                          |
| \f          | 匹配一个换页符。等价于 \x0c 和 \cL。                         |
| \n          | 匹配一个换行符。等价于 \x0a 和 \cJ。                         |
| \r          | 匹配一个回车符。等价于 \x0d 和 \cM。                         |
| \s          | 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 |
| \S          | 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。                  |
| \t          | 匹配一个制表符。等价于 \x09 和 \cI。                         |
| \v          | 匹配一个垂直制表符。等价于 \x0b 和 \cK。                     |
| \w          | 匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。         |
| \W          | 匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’。                 |
| \xn         | 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41′ 匹配 “A”。’\x041′ 则等价于 ‘\x04′ & “1″。正则表达式中可以使用 ASCII 编码。. |
| \num        | 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1′ 匹配两个连续的相同字符。 |
| \n          | 标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 |
| \nm         | 标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。 |
| \nml        | 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 |
| \un         | 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。 |



常用正则表达式：

| 用户名       | /^[a-zA-Z0-9_-]{4,16}$/                                      |
| ------------ | ------------------------------------------------------------ |
| QQ号码       | /^[1-9] [0-9] {4,10}$/                                       |
| 密码强度     | /^.*(?=.{6,}) (?=.*\d) (?=.*[A-Z]) (?=.*[a-z])(?=.*[!@#$%^&*? ]).*$/ |
| 正整数       | /^\d+$/                                                      |
| 负整数       | /^-\d+$/                                                     |
| 整数         | /^-?\d+$/                                                    |
| 正数         | /^\d*\.?\d+$/                                                |
| 负数         | /^-\d*\.?\d+$/                                               |
| 数字         | /^-?\d*\.?\d+$/                                              |
| Email        | /^([A-Za-z0-9_\-\.])+\@([A-Za-z0-9_\-\.])+\.([A-Za-z]{2,4})$/ |
| 手机号码     | /^((13[0-9])\|(14[5\|7])\|(15([0-3]\|[5-9]))\|(18[0,5-9]))\d{8}$/ |
| 身份证号     | /^[1-9]\d{5}(18\|19\|([23]\d))\d{2}((0[1-9])\|(10\|11\|12))(([0-2][1-9])\|10\|20\|30\|31)\d{3}[0-9Xx]$/ |
| URL          | http://([\w-]+\.)+[\w-]+(/[\w- ./?%&=]*)?                    |
| IPv4地址     | /^(?:(?:25[0-5]\|2[0-4][0-9]\|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]\|2[0-4][0-9]\|[01]?[0-9][0-9]?)$/ |
| 十六进制颜色 | /^#?([a-fA-F0-9]{6}\|[a-fA-F0-9]{3})$/                       |
| 日期         | /^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]\|1[0-2])-(?:0[1-9]\|1[0-9]\|2[0-8])\|(?:0[13-9]\|1[0-2])-(?:29\|30)\|(?:0[13578]\|1[02])-31)\|(?:[0-9]{2}(?:0[48]\|[2468][048]\|[13579][26])\|(?:0[48]\|[2468][048]\|[13579][26])00)-02-29)$/ |
| 微信号       | /^[a-zA-Z] ([-_a-zA-Z0-9]{5,19})/                            |
| 车牌号       | /^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/ |
| 包含中文     | /[\u4E00-\u9FA5]/                                            |



```js
        // var age = "18"; //判断：1~3位纯数字
        // var reg = /^\d{1,3}$/; //以/^开始，中间写正则内容，以$/结束
        // var b = reg.test(age); //验证age变量是否符合reg的匹配
        // if(b == true){
        //     console.log("验证通过!");
        // }else{
        //     console.log("格式错误!");
        // }

        var name = "abc123";
        var reg = new RegExp("^[a-zA-Z0-9]{5,8}$");//大小写字母和数字的组合(特殊字符不能出现) 5~8位
        if(reg.test(name)){
            console.log("验证通过!");
        }else{
            console.log("格式错误!");
        }
```



## 3.7 日期对象

```
var d = new Date();

var year = d.getFullYear();//年
var month = d.getMonth() + 1;//月份0~11
var day = d.getDate(); //几号
var h = d.getHours(); //小时
var m = d.getMinutes(); //分钟
var s = d.getSeconds(); //秒
var ms = d.getMilliseconds(); //毫秒 1000毫秒
```



## 3.8 函数

* 使用关键字function定义函数

```
function 函数名(形参列表){
	//函数体
	return 返回值;
}
```

* 函数声明后不会立即执行，会在我们需要的时候调用到
* 注意：
  * 形参：一定不要带数据类型
  * 分号是用来分隔可执行JavaScript语句，由于函数声明不是一个可执行语句，所以不以分号结束



### 3.8.1 无返回值

```
function qiuhe(a,b){
	var he = a + b;
	alert("两数之和:"+he);
}
qiuhe(3,4);
```



### 3.8.2 有返回值

```
function qiuhe(a,b){
	var he = a + b;
	return "两数之和:" + he;
}
var s = qiuhe(3,4);
alert(s);
```



### 3.8.3 参数对象

在函数内部，使用参数列表的属性

```
function func(a,b,c){
	alert(arguements.length); //获得参数个数
	alert(arguements[1]); //获得下标为1的参数
}
```



### 3.8.4 构造函数

函数同样可以通过内置的JavaScript函数构造器（Function()）定义

```
var myFunction = new Function("a","b","return a*b");
var x = myFunction(4,3);
console.log(x);
```

注：上述函数以分号结尾，因为它是一个执行语句。



### 3.8.5 匿名函数

没有名称的函数

```
var a = function(x,y){
	return x+y;
}
console.log(a(2,3));
```



### 3.8.6 全局函数

* isNaN：检查器参数是否是非数字值

```
console.log(isNaN(123));//f
console.log(isNaN(-1,23));//f
console.log(isNaN(5-2));//f
console.log(isNaN(0));//f
console.log(isNaN("hello"));//t
console.log(isNaN(12a3));//t
```

* eval：用来转换字符串中的运算

```
var s = "1+2";
console.log(s);
console.log(eval(s));
```

* encodeURI 与 decodeURI

```
var name = "拉勾网";
console.log(name);
name = encodeURI(name); //转码
console.log(name);
name = decodeURI(name); //解码
console.log(name);
```



### 3.8.7 闭包

1. 闭包的概念：指有权访问另一个函数作用域中的变量的函数，一般情况就是在一个函数中包含另一个函数
2. 闭包的作用：访问函数内部变量，保持函数在环境中一直存在，不会被垃圾回收机制处理；

简单地说：就是在函数的局部范围内声明一个封闭的环境，此环节不会被垃圾回收探测到。保证了数据的安全唯一性

想了解闭包，首先要了解声明是全局变量，什么是局部变量

```js
        var a = 10;//全局变量，声明的时候可以不使用var
        function test1(){
            b = 20;//不使用var声明的变量，就是全局变量
            var c = 30;//用var声明，并且在函数的内部，这样的变量叫做局部变量，有效范围只能在其声明的函数内部
            console.log(c);
        }
        function test2(){
            console.log(c);//c is not defined(c变量没有定义)
        }
        test1();
        test2();
```

需求：统计方法执行了多少次

```js
var count = 0; //执行数量

function test1(){
	count++; //递增
}

test1();
test1();
test1();

console.log(count);
```

count不安全，因为是全局变量

如何才能安全呢？将count声明为局部变量

```js
        function test1(){
            var count = 0;//局部变量
            return count++; //外部无法访问count，只能通过return才能将count变量返回，并输出
        }
        test1();
        test1();
        test1();
```

结果一直是0，因为每次调用test1()方法，方法体的第一句就是还原，无论曾经的值是多少。

突发奇想，如果在test1()函数里，再嵌套一个函数，js是支持函数嵌套的

```js
        function test1(){
            var count = 0;//局部变量
            function jia(){
            return count++;
            }
            jia();
            return count; //外部无法访问count，只能通过return才能将count变量返回，并输出
        }
        test1();
        test1();
        test1();
        console.log(count);
```

如果每次只调用test1()里面的jia()就好了，OK，闭包帮你解决此问题

```js
        function test1(){
            var count = 0;//局部变量
            function jia(){
            return count++;
            }
            jia();
            return jia();
        }
        var fn = test1(); //fn => function jia(){return count++;}
        fn();
        fn();
        console.log(fn());
```

闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰

直观的说就是形成一个不销毁的栈环境。

* 闭包的优点：方便使用上下文中声明的局部变量 逻辑紧密，可以在一个函数中再创建个函数，避免了传参的问题。
* 闭包的缺点：因为使用闭包，可以使函数在执行完后不被销毁，保留在内存中，如果大量使用闭包就会造成内存泄露，内存消耗很大



3.9 弹框输出

* 普通弹框alert("hello，拉钩");
* 控制台日志输出console.log("谷歌浏览器按F12进入控制台");
* 页面输出 document.write("<h2>我爱你中国</h2>");
* 确认框 confirm("确定删除吗?");

```js
        var b = confirm("确定删除吗?");
        if(b){
            document.write("<h1>删除成功</h1>");
        }else{
            document.write("<h1>你取消了操作</h1>");
        }
```

* 输入框 prompt("请输入姓名：");

```js
        var name = prompt("请输入你的名字:");
        document.write("<h1>大名："+name+"!</h1>");
```



# 4.DOM 操作

* 在一个html页面中，会使用很多标签来规划制作页面
* 每个标签都有它存在的意义，如果我们想要动态的修改某个标签的值，那我们就需要在页面中查找到这个标签元素
* 如何查找到这个元素是个难题，W3C组织得工程师们，突然看到了一棵大叔，我要是想找到某一片叶子，应该怎么做？
* "顺藤摸瓜"，主树干有分支，每个分支还有许多小分支，只要把这个分支的结构整理清楚，任何一片叶子都不是难事
* 叶子和大树的一些启发，工程师们开会讨论就定了这个理论“文档对象模型”
* 文档对象模型，就是将页面中所有的标签元素都看成是一个对象(一片叶子)，主树干定义为根节点（根元素），所有的标签都是从根元素延伸出去的，摸清结构，找到某个标签就不再困难了
  * 在节点树中，顶端节点就是根节点(root)
  * 每个节点都有父节点（出了根节点）
  * 任何一个节点都可以拥有任意数量的子节点
  *  同胞是拥有相同父节点的节点

```js
<html>
	<head>
		<meta charset="utf-8”>
		<title>拉勾教育</title>
	</head>
	<body>
		<h1>第一节:HTNL DOM</hI><p>He1o war 1d!		</body>
</html>
```

从上面的HTML中：

* <html> 节点没有父节点；它是根节点
*  <head> 和 <body>的父节点是 <html> 节点

* 文本节点"Hello world!"的父节点是<p>节点

并且：

* <html> 节点拥有两个子节点：<head> 和 <body>
*  <head> 节点拥有两个子节点： <meta>  与  <title>  节点

* 《<title>》 节点也拥有一个子节点：文本节点“DOM教程"<h1> 和 <p> 节点是同胞节点，同时也是<body> 的子节点

并且：

* 《<head>》元素是<htm>元素的首个子节点
* <body> 元素是<htm> 元素的最后一个子节点
* 《<h1>》 元素是 <body> 元素的首个子节点
* 《<p>》 元素是<body 元素的最后一个子节点

js为我们提供了很多种方法来实现在页面查找某个节点



## 4.1 DOM访问

* getElementById：通过id属性获取元素节点对象
  * 案例：当账号为空时，阻止表单提交

```js
<body>
    <form action="xxx" onsubmit="return login()">
        <p>账号:<input id="username"></p>
        <p>电话:<input id="phone"></p>
        <p><button>登录</button></p>
    </form>
    <script>
        function login(){
            var name = document.getElementById("username").value;
            if(name == ""){
            alert("账号不能为空");
            return false; //阻止表单的提交
            }
            return true;//放心，让表单提交
        }
    </script>
</body>
```

* getElementByName：通过name属性获得元素节点对象集
  * 案例：购物车全选效果

```html
<body>
    <table border="1" cellspacing="0">
        <tr>
            <td><input type="checkbox" onchange="quan(this)">全选</td>
            <td>名称</td>
            <td>单价</td>
        </tr>
        <tr>
            <td><input type="checkbox" name="one">1</td>
            <td>功能性饮料-尖叫</td>
            <td>4.0</td>
        </tr>
        <tr>
            <td><input type="checkbox" name="one">2</td>
            <td>火腿肠</td>
            <td>3.0</td>
        </tr>
        <tr>
            <td><input type="checkbox" name="one">3</td>
            <td>包子</td>
            <td>1.5</td>
        </tr>
    </table>
    
    <p>
        <button>提交订单</button>
    </p>
    <script>
        function quan(all){
            var arr = document.getElementsByName("one");
            for(var i = 0; i < arr.length; i++){
                arr[i].checked = all.checked;//将全选框的状态，赋值给每一个复选框
            }
        }
    </script>
</body>
```



* getElementByTagName：通过标签名称获得元素节点对象集
  * 案例：表格履行变色

```
<body>
    <table border="1" cellspacing="0">
        <tr>
            <td><input type="checkbox" onchange="quan(this)">全选</td>
            <td>名称</td>
            <td>单价</td>
        </tr>
        <tr>
            <td><input type="checkbox" name="one">1</td>
            <td>功能性饮料-尖叫</td>
            <td>4.0</td>
        </tr>
        <tr>
            <td><input type="checkbox" name="one">2</td>
            <td>火腿肠</td>
            <td>3.0</td>
        </tr>
        <tr>
            <td><input type="checkbox" name="one">3</td>
            <td>包子</td>
            <td>1.5</td>
        </tr>
        <tr>
            <td><input type="checkbox" name="one">4</td>
            <td>功能性饮料-尖叫</td>
            <td>4.0</td>
        </tr>
        <tr>
            <td><input type="checkbox" name="one">5</td>
            <td>火腿肠</td>
            <td>3.0</td>
        </tr>
        <tr>
            <td><input type="checkbox" name="one">6</td>
            <td>包子</td>
            <td>1.5</td>
        </tr>
        <tr>
            <td><input type="checkbox" name="one">7</td>
            <td>火腿肠</td>
            <td>3.0</td>
        </tr>
        <tr>
            <td><input type="checkbox" name="one">8</td>
            <td>包子</td>
            <td>1.5</td>
        </tr>
    </table>
    <script>
        var rows = document.getElementsByTagName("tr");
        for(var i = 0; i < rows.length; i++){
            if(i % 2 == 0){
                rows[i].style.backgroundColor = "pink";
            }
        }
    </script>
</body>
```



## 4.2 DOM修改

* 修改HTML DOM意味着许多不同的方面：
  * 改变HTML内容
  * 改变CSS样式
  * 改变HTML属性
  * 创建新的HTML元素
  * 删除已有的HTML元素
  * 改变事件（处理程序）

1. 改变一个<p> 元素的HTML内容：

```js
<body>
    <button onclick="test()">点我试试</button>
    <script>
        function test(){
       document.getElementById("hello").innerHTML="走啊，喝点去~!";
        }
    </script>
    <h2 id="hello">你好!</h2>
</body>
```

2. 改变一个段落的HTML样式

```js
<body>

    <button onclick="test()">点我试试</button>
    <button onclick="chou()">你瞅啥</button>
    <script>
        function test(){
            document.getElementById("hello").innerHTML="走啊，喝点去~!";
        }
        function chou(){
            document.getElementById("hello").style.color = "red";
            document.getElementById("hello").style.fontFamily="宋体";
        }
    </script>
    <h2 id="hello">你好!</h2>
</body>
```



### 4.2.1 添加节点

* 点击按钮，在页面中创建一张图片

```js
<body>
    <button onclick="add()">添加</button>
    <div></div>

    <script>
        function add(){
            var img = document.createElement("img");
            img.setAttribute("src","D:/剪辑视频库/素材库/1.jpg");
            img.setAttribute("title","小猫咪");
            img.setAttribute("id","cat");
            
            var divs = document.getElementsByTagName("div");
            divs[0].appendChild(img);
        }
    </script>
</body>
```

### 4.2.2 删除节点

* 点击按钮，把上面刚创建的图片从页面上删除

```js
<body>
    <button onclick="add()">添加</button>
    <button onclick="del()">删除</button>
    <div></div>

    <script>
        function add(){
            var img = document.createElement("img");
            img.setAttribute("src","D:/剪辑视频库/素材库/1.jpg");
            img.setAttribute("title","小猫咪");
            img.setAttribute("id","cat");
            
            var divs = document.getElementsByTagName("div");
            divs[0].appendChild(img);
        }

        function del(){
            var img = document.getElementById("cat");
            img.parentNode.removeChild(img);//必须通过父节点才能删除子节点
        }
    </script>
</body>
```

### 4.2.3 替换节点

* 点击按钮，把上面刚创建的图片替换成另一张

```js
<body>
    <button onclick="add()">添加</button>
    <button onclick="del()">删除</button>
    <button onclick="rep()">替换</button>
    <div></div>

    <script>
        function add(){
            var img = document.createElement("img");
            img.setAttribute("src","D:/剪辑视频库/素材库/1.jpg");
            img.setAttribute("title","小猫咪");
            img.setAttribute("id","cat");
            
            var divs = document.getElementsByTagName("div");
            divs[0].appendChild(img);
        }

        function del(){
            var img = document.getElementById("cat");
            img.parentNode.removeChild(img);//必须通过父节点才能删除子节点
        }

        function rep(){
            var imgold = document.getElementById("cat");
            //通过修改元素的属性，做的替换
            // img.setAttribute("src","D:/剪辑视频库/素材库/2.jpg");
            var imgnew = document.createElement("img");
            imgnew.setAttribute("src","D:/剪辑视频库/素材库/2.jpg");
            imgold.parentNode.replaceChild(imgnew,imgold);

        }
    </script>
</body>
```



## 4.3 事件

js捕获某个动作而做出的反馈

HTML事件的例子：

* 当用户点击鼠标时
* 当网页已加载时
* 当图片已加载时
* 当鼠标移动到元素上时
* 当输入字段被改变时
* 当HTML表单被提交时
* 当用户触发按键时



### 4.3.1 窗口事件(Window Events)

仅在body 和frameset元素中有效

* onload 当文档被载入时执行脚本

```js
<body onload="test()">
    <script>
        function test(){
            document.write("哈哈哈哈");
        }
    </script>
</body>
```



### 4.3.2 表单元素事件(FORM Element Events)

仅在表单元素中有效

* onblur 当元素**失去焦点**时执行脚本
* onfocus 当元素**获得焦点**时执行脚本

```js
<body onload="test()">
    <script>
        function test(){
            // document.write("哈哈哈哈");
        }
        function a(){
            console.log("获得焦点==被激活");
        }
        function b(){
            console.log("bbb");
        }
    </script>
    <form action="">
        <p>账号：<input onfocus="a()" onblur="b()"></p>
        <p>账号：<input></p>
    </form>
</body>
```



### 4.3.3 鼠标事件(Mouse Events)

* onclick 当鼠标被单击时执行脚本
* ondblclick 当鼠标被双击时执行脚本
* onmouseout 当鼠标指针移出某元素时执行脚本
* onmouseover 当鼠标指针悬停于某元素之上时执行脚本

![image-20230218123340903](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20230218123340903.png)

```js
<style>
    img{
        width: 30%;
        border: 5px solid white;
    }
</style>
<body>
    <img src="D:/剪辑视频库/素材库/1.jpg" onmouseover="shang(this)" onmouseout="xia(this)" onclick="dan()">
    <img src="D:/剪辑视频库/素材库/1.jpg" onmouseover="shang(this)" onmouseout="xia(this)" ondbclick="shuang()">
    <img src="D:/剪辑视频库/素材库/1.jpg" onmouseover="shang(this)" onmouseout="xia(this)">

    <script>
        function dan(){
            alert("点了一下");
        }
        function shuang(){
            alert("连续快速点了两下");
        }
        function shang(img){
            img.style.border="5px solid red";
        }
        function xia(img){
            img.style.border="5px solid white";
        }
    </script>
</body>
```



### 4.3.4 键盘事件

* onkeydown 按下去
* onkeyup 弹上来

```js
<body>
    <script>
        window.onkeydown = function(){
            //event：事件源(按键)
            // console.log("按键编码："+event.keycode);
            if(event.keycode=="13"){
                alert("登录成功!");
            }
        }

        window.onkeyup = function(){
            console.log(event.keycode);//按住按键不松手是不会触发的，当松手时，按键回弹，则触发
        }
    </script>
</body>
```



### 4.3.5 事件冒泡

* 创建两个div，一个大一些，一个小一些

```js
<style>
    #father{
        width: 200px;
        height: 200px;
        background-color: black;
        padding: 10px;
    }
    #child{
        width: 100px;
        height: 100px;
        background-color: greenyellow;
    }
</style>
<body>
    <div id="father">
        <div id="child"></div>
    </div>
    <script>
        //代码不重要，重要的是知道这个事件发生，是正常现象
        document.getElementById("father").addEventListener("click",function(){
            alert("父级元素的事件被触发："+this.id);
        });

        document.getElementById("child").addEventListener("click",function(e){
            e.stopPropagation();//取消事件的冒泡机制
            alert("子级元素的事件被触发："+this.id);
        });
    </script>
</body>
```

先子，后父。事件的触发顺序自内向外，这就是事件冒泡



### 4.3.6 事件捕获

* 还是刚才创建两个div，一个大一些，一个小一些

```js
<style>
    #father{
        width: 200px;
        height: 200px;
        background-color: black;
        padding: 10px;
    }
    #child{
        width: 100px;
        height: 100px;
        background-color: greenyellow;
    }
</style>
<body>
        <div id="father">
        <div id="child"></div>
        </div>
        <script>
            document.getElementById("father").addEventListener("click",function(){
            alert("父级："+this.id);
            },true);

            document.getElementById("child").addEventListener("click",function(){
            alert("子级："+this.id);
            },true);
        </script>
</body>
```



## 4.4 面向对象OOP

* 使用Object创建通用对象

```
<body>
    <script>
        var user = new Object();
        user.name = "吕布";
        user.age = 21;
        user.say = function(){
            console.log("大家好，我叫："+this.name+",我今年"+this.age+"岁了")
        }
        user.say();
    </script>
</body>
```

* 使用构造函数

```
<body>
    <script>
        function userinfo(name,age){
            this.name = name;
            this.age = age;
            this.say = function(){
                console.log("大家好，我叫："+this.name+",我今年"+this.age+"岁了");
            }
        }
        var user = new userinfo("詹姆斯",35);
        user.say();
    </script>
</body>
```

* 使用直接量

```
<body>
    <script>
        var user = {
            username : "孙悟空",
            age : 520,
            say:function(){
                console.log("大家好，我叫："+this.username+",我今年"+this.age+"岁了");
            }
        };
        user.say();
    </script>
</body>
```

## 4.5 JSON

* 大家在互联网上来回传递数据，如果没有一个统一的格式，解析起来的难度很大（每个人的编码喜好不一样）
* JSON(JavaScript Object Notation)是一种轻量级的数据交换格式
* 易于人阅读和编写，同时也易于机器解析和生成

{

​	属性1：值1，

 	属性2：值2，

}

```js
<body>
    <script>
        var json1 = {"usernmae":"吕布","age":31};
        console.log("姓名:"+json1.usernmae,",年龄:"+json1.age);

        //json数组
        var jsonarr = [{"name":"貂蝉","age":18},{"name":"小乔","age":17}];
        console.log("姓名:"+jsonarr[0].name,",年龄:"+jsonarr[0].age);
        console.log("姓名:"+jsonarr[1].name,",年龄:"+jsonarr[1].age);

        //复杂的json对象
        var long = {
            name:"赵云",
            sex:"男",
            hobby: ["玉兰白龙驹","龙胆亮银枪","青釭剑"]
        };
        console.log(long.name+"的主攻武器:"+long.hobby[1]);
    </script>
</body>
```



# 5.BOM操作

就是javascript对浏览器的一些常规操作的方法

## 5.1 window对象

窗口特征（window Features）

| channelmode=yes\|no\|1\|0 | 是否使用剧院模式显示窗口                                     |
| ------------------------- | ------------------------------------------------------------ |
| directories=yes\|no\|1\|0 | 是否添加目录按钮，默认为yes                                  |
| fullscreen=yes\|no\|1\|0  | 是否使用全屏模式显示浏览器，默认是no。处于全屏模式的窗口必须同时处于剧院模式 |
| height=pixeis             | 窗口文档显示区的高度，以像素计                               |
| left=pixels               | 窗口的x坐标，以像素计                                        |
| location=yes\|no\|1\|0    | 是否显示地址字段，默认是yes                                  |
| menubar=yes\|no\|1\|0     | 是否显示菜单栏，默认是yes                                    |
| resizable=yes\|no\|1\|0   | 窗口是否可调节尺寸，默认是yes                                |
| scrollbars=yes\|no\|1\|0  | 是否显示滚动条，默认是yes                                    |
| status=yes\|no\|1\|0      | 是否添加状态栏，默认是yes                                    |
| titlebar=yes\|no\|1\|0    | 是否显示标签栏，默认是yes                                    |
| toolbar=yes\|no\|1\|0     | 是否显示浏览器的工具栏，默认是yes                            |
| top=pixels                | 窗口的y坐标                                                  |
| width=pixels              | 窗口的文档显示区的宽度，以像素计                             |

```js
<body>
    <button onclick="kai()">极速入职</button>
    <script>
        function kai(){
            window.open("http://lagou.com","拉勾网","width=500,height=300,left=400");
            // window.open("http://lagou.com","拉勾网","fullscreen=yes");//IE浏览器才生效
        }
    </script>
</body>
```



### 5.1.1 screen屏幕对象

我想知道我的电脑屏幕多大？实际上，得到的就是分辨率

```js
<body>
    <button onclick="test()">获取</button>

    <script>
        function test(){
            console.log("宽:"+screen.width+"px,高:"+screen.height+"px");
        }
    </script>
</body>
```



### 5.1.2 location定位

包含有关当前URL的信息，通常用来做页面跳转

```html
<body>
    <button onclick="test()">测试</button>
    <script>
        function test(){
            console.log("当前页面的URL路径地址：",location.href);
            location.reload();//重新加载当前页面(刷新)
            location.href="http://lagou.com";//跳转页面
        }
    </script>
</body>
```



### 5.1.3 history浏览器

history对象会记录浏览器的痕迹

* a.html

```
<body>
    <a href="b.html">去b页面</a>
</body>
```

* b.html

```
<body>
    <button onclick="hui()">返回</button>
    <script>
        function hui(){
            history.go(-1);//上一级页面
            history.back();//与go(-1)等价
        }
    </script>
</body>
```



### 5.1.4 navigator 导航

window.navigator 对象包含有关访问者浏览器的信息

```js
<body>
    <script>
        var str = "";
        str +="<p>浏览器的代号："+ navigator.appCodeName +"</p>";
        str +="<p>浏览器的名称："+ navigator.appName +"</p>"  
        str +="<p>浏览器的版本："+ navigator.appVersion +"</p>" 
        str +="<p>硬件平台："+ navigator.platform +"</p>" 
        str +="<p>用户代理："+ navigator.userAgent +"</p>" 
        str +="<p>启用cookie："+ navigator.cookieEnabled +"</p>" 

        document.write(str);
    </script>
</body>
```



### 5.1.5 存储对象

用起来和我们在java中map很相似，都是键值对的方式存数据

#### 5.1.5.1 本地存储 localStorage

在关闭窗口或标签页之后会删除这些数据

* 保存数据

```js
localStorage.setItem("name1","吕布");
```

* 提取数据

```js
localStorage.getItem("name1");
```

* 删除数据

```js
localStorage.removeItem("name1");
```

多样化操作

```js
<body>
    <script>
        //三种方式保存数据
        localStorage["a"] = 1;
        localStorage:b = 2;
        localStorage.setItem("c",3);

        //查看数据类型
        console.log(typeof localStorage["a"]);
        console.log(typeof localStorage["b"]);
        console.log(typeof localStorage["c"]);

        //第一种方式读取数据
        var a = localStorage.a;
        console.log(a);

        //第二种方式读取数据
        var b = localStorage["b"];
        console.log(b);

        //第三种方式数据读取
        var c = localStorage.getItem("c");
        console.log(c);
    </script>
</body>
```



5.1.5.2 会话存储 sessionStorage

会话，就是保持浏览器别关闭

关闭浏览器就等于结束了一次会话

开启浏览器就意味着创建了一次会话

* 保存数据

```js
sessionStorage.setItem("name","貂蝉");
```

* 提取数据

```js
sessionStorage.getItem("name");
```

* 删除指定键的数据

```js
sessionStorage.removeItem("name");
```

* 删除所有数据

```js
sessionStorage.clear();
```

案例：记录点击了几下按钮

```js
<body>
    <button onclick="count()">点我一下</button>
    <h3 id="result"></h3>
    <script>
        function count(){
            if(sessionStorage.getItem("clickCount")){
            sessionStorage.setItem("clickCount", Number(sessionStorage.getItem("clickCount"))+1);
        }else{
            sessionStorage.setItem("clickCount",1);
        }
        document.getElementById("result").innerHTML="已经点击了"+sessionStorage.getItem("clickCount")+"次!";
    }
    </script>
</body>
```



## 5.2 计时操作

### 5.2.1 周期性定时器 setInterval

setInterval(1,2)：周期性触发代码exp（常用）

1：执行语句

2：时间间隔，单位为毫秒

* 闪烁的字体（一秒一变色）

```js
<body>
    <h1 id="title">拉勾网:极速入职</h1>
    <script>
        var colors = ["red","blue","yellow","pink","orange","black"];

        var i = 0;
        function bian(){
            document.getElementById("title").style.color = colors[i++];
            if(i == colors.length + 1){
                i = 0;
            }
        }
        setInterval(bian,100);//每隔0.1秒，执行一次bian
    </script>
</body>
```

* 案例：在闪烁字体的基础上扩展，闪烁的电子时钟

```js
<body>
    <h1 id="title"></h1>
    <script>
        function time(){
            var d = new Date();
            var str = d.getFullYear()+"年"+(d.getMonth()+1)+"月"+d.getDate() +"日"+d.getHours() +" 点"+d.getMinutes()+"分"+d.getSeconds()+"秒";
            document.getElementById("title").innerHTML = str;
        }
        setInterval(time,1000);//每隔一秒，执行一次时间函数
    </script>
</body>
```



### 5.2.2 停止定时器 clearInterval

案例：模拟年会抽奖

```js
<body>
    <img id="tu" src="D:/剪辑视频库/素材库/1.jpg" width="50%">
    <br>
    <button onclick="begin()">开始</button>
    <button onclick="stop()">停止</button>

    <script>
        var arr = ["1.jpg","2.jpg","3.jpg","4.jpg"];
        function begin(){
            timer = setInterval(bian,100);//没有使用var,所以timer是全局变量
        }
        function stop(){
            clearInterval(timer);//停止定时器
        }
        function bian(){
            var i = Math.floor(Math.random()* arr.length);//0~4
            document.getElementById("tu").src="D:/剪辑视频库/素材库/"+arr[i];
        }
    </script>
</body>
```

### 5.2.3 一次性定时器 setTimeout

相当于前进的效果，只执行一次

```js
<body>
    <script>
        function bian(){
            document.body.style.backgroundColor = "red";
        }
        //3秒之后调用
        setTimeout(bian,3000);
    </script>
</body>
```

